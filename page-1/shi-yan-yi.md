# 实验一

## 实验项目一

### 1.1 项目名称

基础实验：原型机

### 1.2 实验目的

（1） 了解冯诺伊曼体系结构；

（2） 理解指令集结构及其作用；

（3） 理解计算机的运行过程，就是指令的执行过程，并初步掌握调试方法。

### 1.3 实验资源

* 阅读教材，掌握冯诺伊曼体系的相关内容；
* 学习课程《最小系统与原型机I》。

为了方便下载直接从github拉取文件

```
git clone https://github.com/WuJean/HNU-CSAPP.git
```

实验环境为Esxi8.0 ubuntu20.04虚拟机 i5 9300h&#x20;

## 实验任务1

### 练习内容

#### 1.按照上述的实验步骤，完成相关操作

进入终端，本机使用的是64位的操作系统，故进入64bit目录中

在32bit中执行命令会出现报错：

```
wjd@wjd:~/HNU-CSAPP/实验一/32bit/1.1$ ./vm32 1.config
-bash: ./vm32: No such file or directory
```

直接运行vm64会发现没有执行的权限

```
chmod +x vm64 //添加执行的权限
```

使用vm64运行配置文件1.config

```
./vm64 1.config
```

我们查看1.config文件的内容

第一行的4，表示原型机的地址为4位，即内存有16个字节

第二行的3，表示数据段为3个字节——0000，0001，0010

第三行的0011，表示从第四个字节，也就是0011开始存放指令

第四行的a.txt，表示指令内容在a.txt中

```
wjd@wjd:~/HNU-CSAPP/实验一/64bit/1.1$ cat 2.config
4
3
0011
b.txt
wjd@wjd:~/HNU-CSAPP/实验一/64bit/1.1$ cat b.txt
1
5 R0 0000
5 R0 R1
1
5 R0 0001
3 R1 R0
6 3
5 0000 0010
7 2
5 0001 0010
5 0010 R0
8 R0
0
```

![](<../.gitbook/assets/image (4).png>)

根据阅读材料《最小系统与原型机》中的指令表可，按照步骤完成实验步骤

### 2. 运行2.config

2.config && b,txt

<pre><code>wjd@wjd:~/HNU-CSAPP/实验一/64bit/1.1$ cat 2.config
4
3
0011
b.txt

wjd@wjd:~/HNU-CSAPP/实验一/64bit/1.1$ cat b.txt
1
5 R0 0000
5 R0 R1
1
5 R0 0001
3 R1 R0
6 3
5 0000 0010
<strong>7 2
</strong>5 0001 0010
5 0010 R0
8 R0
0
</code></pre>

1. 第一步 提示要执行位于内存0011处的指令“1”，即等待输入一个整数值。此时输入si则表示执行此指令，将输入得指令存储到寄存器R0中
2. 第二步 “5 R0 0000” 将R0的值传送到内存0000中
3. 第三步 “5 R0 R1”将寄存器R0的值传送到寄存器R1中
4. 第四步 “1” 等待输入一个整数，存储到寄存器R0中
5. 第五步 ”3 R1 R0“ R0的值减去R1中的值，结果放在R0中，当结果大于 0 时， R3 中赋值为 1，当结果小于 0 时，R3 中赋值为-1，当结果等于 0 时，R3 中赋值为 0
6. 第六步 ”6 3“ 判断跳转指令，如果R3为1，跳转到当前指令+3条执行，否则执行下一条指令
7. 第七步” 5 0000 0010“ 将内存中0000的值传送内存0010中
8. 第八步 ”7 2“ 跳转到当前指令+2条处执行
9. 第九步 ”5 0010 R0“ 将内存中0010处的值传给寄存器R0
10. 第十步 ”8 R0“ 将R0的值传送到显存-》内存地址0011中
11. 第十一步 ”0“ 停机

验证执行过程 b.txt中有两次输入，分别将两次输入in1和in2存储到R1和R0中，让R0-R1，结果存储到R0中；若R1>R0，则使用跳转命令将存储在内存0000中的in1的值赋给R0，并输出；若R1<=R0,则将输出in2.

本程序为一个显示两个数中较大输入数的程序，验证如下：

![](<../.gitbook/assets/image (3).png>)

继续选择其他的测试数据，当输入128 20时出现异常情况，尝试输入256 20；129 20等几组数据，输出都与预期不符：

```
vm>c
128
20
-128

vm>c
256
20
20

vm>c
129
20
127
```

在命令“1”中要求我们输入一个0-256内的数，由于要将输入到寄存器R0中的数存储到八位内存中，所以内存中数的值的范围为-128—127；我们可以通过执行将寄存器中的值放入内存中，查看内存中二进制数的保存方式来验证我们的猜测：

![](<../.gitbook/assets/image (2).png>)

128由于溢出，在寄存器中变成了-128；在该程序中，输出哪个值取决于in2-in1的结果，20-（-128）=148>127，故in2-in1的结果为负，R3=-1，输出in1，此时的in1为-128

同样的，第二组输入中输入256，在寄存器中变成了0，20-0>0故输出in2，此时in2为20

![](<../.gitbook/assets/image (8).png>)

第三次输出中我们发现输出的数在符号和值上与输入毫无关联，尝试一步步执行找出关键点：

![](<../.gitbook/assets/image (5).png>)

我们惊讶的发现在将寄存器R0中的-127放入内存中时，符号位居然为0，也就是说内存中存储的为127.寄存器和内存存储的不一致性导致了输出的异常，我们找到该cpu的源代码一探究竟：

```
cd ../1.2
vi cpu.c
//为了方便观察打开vim的行号 :set number
```

我们找到执行mov操作的函数：

```
case '5':		//拷贝
			split(instruction_buffer," ",revbuf,&num);
//			printf("%d\n",num);
			if(3>num)
				*result=-1;	//出错
			else
				ExecuteCopy(revbuf[1],revbuf[2],result);
			if(*result!=-1) *result=5;			
			PC++;
			break;
```

```
split(instruction_buffer," ",revbuf,&num);
```

函数的声明：

void split(char \*src,const char \*separator,char \*\*dest,int \*num)&#x20;

1. \*src：要进行分割的字符串地址，&#x20;
2. \*separator:分隔符，设置为常量字符串,这里的分隔符可以为字符串
3. \*\*dest：分割结束后数据存储的地址，二维数组
4. \*num:返回的是字符串中存在的分隔符的数量。&#x20;

split将缓存中命令instruction\_buffer的命令、寄存器、目标地址分割开，分别存储在revbuf；此命令有3个操作数，若操作数少于3则报错-1；若无报错则执行&#x20;

```
ExecuteCopy(revbuf[1],revbuf[2],result)
```

ExecuteCopy函数中在处理寄存器值到内存值的时候用了

```c
BCharsToInt
```

可能是在执行这条命令的时候无视了寄存器中的符号，因为在命令“1”中要求我们输入的是0-256大小的数，并未考虑负数的情况，也有可能是为了避免之后运算出现错误。

但是该函数并未给出实现的细节，故无法详解其原理或做出修改，希望老师能做出改进。

#### 3.运行 3.config

3.conif c.txt

```
5
3
00011
c.txt

4 0 R1
5 R1 00001
1
5 R0 00000
5 00000 R0
4 0 R1
3 R1 R0
6 2
7 12
5 00001 R0
5 00000 R1
2 R0 R1
5 R1 00010
5 00010 00001
5 00000 R0
4 1 R0
3 R1 R0
5 R0 00011
5 00011 00000
7 -15
5 00000 R0
8 R0
0
```

1. “4 0 R1” 将0放到R1中&#x20;
2. “5 R1 00001” 将R1 放到内存00001中
3. “1”输入一个数in1到R0中
4. “5 R0 00000”将R0中的数放到内存00000中
5. “5 00000 R0”将内存00000的值放到R0中（利用系统的缺陷将循环数取正）
6. “4 0 R1” 将0放到R1中
7. “3 R1 R0”R0-R1 也就是in1-0，根据in1的正负来决定R3的值 R0=in1
8. “6 2” 若in1>0则继续执行，若in1<=0则跳转到最后输出in1
9. 后面的东西将每次相加的结果存储到00010中，再将结果减去1作为下次的输入

尝试的输入过程如下：

1. 5 4 5
2. 4 8 9
3. 8 16 17&#x20;
4. 16 32 33&#x20;

若in1-1为2的n次方，则循环累加到128，128-0==0，退出循环输出-128；否则进入死循环；

![](<../.gitbook/assets/image (1).png>)



### 思考题

#### 1. 如何基于这些指令实现两个整数的乘法与除法？

* 基于加法和减法指令实现两个整数的乘法可以采用加法累加法。
* 基于加法和减法指令实现两个整数的除法可以采用减法计数法。

#### 2. 原型机I的指令集是否完备？如果是，那么如何证明？如果不是，那么要增加哪些指令？

在计算机科学中，如果一个指令集能够实现图灵完备性，就称该指令集为“完备指令集”。简单来说，图灵完备性是指能够模拟图灵机的能力，而图灵机是一种被认为是可计算的模型。

根据可计算性理论，我们知道，只要一个系统能够模拟图灵机，就能够计算所有可计算函数。因此，如果原型机I的指令集能够模拟图灵机，那么它就是完备的。

具体来说，要实现图灵完备性，需要支持以下操作：

1. 可以读写无限长的内存。
2. 可以跳转到任意指令执行。
3. 可以进行条件分支和循环控制。
4. 可以实现简单算术运算和逻辑运算。

我们需要添加：

1. 算术指令：用于执行基本的算术运算，例如加、减、乘、除等操作。
2. 逻辑指令：用于执行基本的逻辑运算，例如与、或、异或、取反等操作。

## 实验任务2

#### 2.1 添加乘法和除法模块

我们扩充指令集首先需要添加指令：

* 乘法 9 R0 R1 R1\*R0 结果放在R1里面
* 除法 10 R0 R1 R1/R0 结果放在R1里面，若不能整除则报错

我们发现在原switch中是通过判断 instruction\_buffer的第一位字符来选择执行哪条指令。当指令扩充到两位数时将无法判断，故我们 需要改变指令判断的形式。

我们选择提取指令的前两位，将其转化成整形，通过判断整形数字来决定执行哪条指令，修改的代码如下：

```c
strncpy(instruction_buffer,memory+(PC-1)*20,20);
//	printf("%s\n",instruction_buffer);
	char op[3];
	strncpy(op,instruction_buffer,2);	//指令数转数字
	// switch(instruction_buffer[0])
	switch(atoi(op))
	{
		case 0:
```

再参考上面的格式扩充指令集：

```c
case 9:		//乘法
		split(instruction_buffer," ",revbuf,&num);
		if(3>num)
			*result=-1;	//出错
		else
			ExecuteMul(revbuf[1],revbuf[2],result);
		if(*result!=-1) *result=2;
		PC++;
		break;
case 10:
		split(instruction_buffer," ",revbuf,&num);
		if(3>num)
			*result=-1;	//出错
		else
			ExecuteDiv(revbuf[1],revbuf[2],result);
		if(*result!=-1) *result=2;
		PC++;
		break;
```

再根据加法的指令函数添加乘法和除法的指令函数：

```c
void ExecuteMul(char source[],char dest[],int *result)
{
	char op;
	if(0==strcmp(source,"R0"))
	 	op=R0;
	else if(0==strcmp(source,"R1"))
		op=R1;
	else if(0==strcmp(source,"R2"))
		op=R2;
	else if(0==strcmp(source,"R3"))
		op=R3;
	else
		*result=-1;
	if(0==strcmp(dest,"R0\n"))
	 	R0*=op;
	else if(0==strcmp(dest,"R1\n"))
		R1*=op;
 	else if(0==strcmp(dest,"R2\n"))
		R2*=op;
	else if(0==strcmp(dest,"R3\n"))
		R3*=op;
	else
		*result=-1;
}
```

```c
void ExecuteDiv(char source[],char dest[],int *result)
{
	char op;
	if(0==strcmp(source,"R0"))
	 	op=R0;
	else if(0==strcmp(source,"R1"))
		op=R1;
	else if(0==strcmp(source,"R2"))
		op=R2;
	else if(0==strcmp(source,"R3"))
		op=R3;
	else
		*result=-1;
	if(0==strcmp(dest,"R0\n")){
		int tmp = R0;
		R0/=op;
		if(tmp!=R0*op) 
			*result = -1;
	}
	 	
	else if(0==strcmp(dest,"R1\n"))
	{
		int tmp = R1;
		R1/=op;
		if(tmp!=R1*op) 
			*result = -1;
	}
 	else if(0==strcmp(dest,"R2\n")){
		int tmp = R2;
		R2/=op;
		if(tmp!=R2*op) 
			*result = -1;
	}
	else if(0==strcmp(dest,"R3\n")){
		int tmp = R3;
		R3/=op;
		if(tmp!=R3*op) 
			*result = -1;
	}
	else
		*result=-1;
}
```

#### 一些很重要的东西

此时我们注意到，在函数中寄存器的加减操作都是通过对char 类型的寄存器R0、R1、R2、R3直接进行操作；出现了char+=char，char/=char的情况，这是一种违反直觉的操作。

通过对实验一 内存中数据存储到寄存器会出现负数，将内存中数据存储到寄存器中会变成正数的操作，以及char类型的数据范围，我们猜测：

**寄存器存储值得方式就是寄存器char类型的值**，范围为-128--127，这很好的解释了 函数中直接用char类型进行运算操作的行为以及实验一中寄存器溢出的行为。

```c
if(0==strcmp(dest,"R0\n")){
		int tmp = R0;
		R0/=op;
		if(tmp!=R0*op) 
			*result = -1;
	}
```

我们尝试对整除的操作进行进一步完善，通过将整除结果乘以除数，判断结果是否等于原来的数来验证该操作是否为整除操作，直接使用char和int的转化来完成该操作，该操作的结果也进一步验证了我我们的想法。

.config d.txt 执行结果:

```
4
3
0011
d.txt

1
5 R0 0000
5 0000 R1
1 
10 R1 R0
8 R0

vm>c
2
8
4
```

按照实验要求添加d.txt文件，其中包含乘法指令：

![](<../.gitbook/assets/image (7).png>)

添加e.txt文件实现加法类型乘法：

![](<../.gitbook/assets/image (6).png>)

### 思考问题

#### 1. 原型机I与原型机II完成乘法和除法操作的方式有何不同？

一个是直接使用char的值乘除，一个是使用加法类型乘法和减法类型除法

#### 2. 在指令集中增加乘法、除法等指令时，原型机中需要增加代码，那么硬件实现上需要增加什么样的部件？

在指令集中增加乘法、除法等指令时，硬件实现上需要增加专门的乘法器和除法器等功能部件。这些部件是基于算术逻辑单元(ALU)进行设计的，并且能够对整数或浮点数执行高效的乘除运算。

乘法器和除法器通常包括多个位宽的加法器和移位器，以实现高速的乘法和除法运算。在设计时，需要考虑到运算的精度、速度和功耗等因素，以及指令集中的需求和实际应用场景。

此外，为了支持乘法和除法等指令，处理器中的控制逻辑和数据通路也需要进行相应的修改和扩展。例如，需要增加新的指令译码器、运算单元、寄存器和数据通路等。

#### 3. 如果一台计算机只支持加法、减法操作，那么能否计算三角函数，对数函数？

虽然一台只支持加法、减法操作的计算机不能直接计算三角函数和对数函数，但是可以通过泰勒级数展开的方式来近似计算这些函数。

泰勒级数是一种将函数表示为多项式的方法，通过对函数进行泰勒级数展开，可以将复杂的函数近似表示为简单的多项式形式，从而在只支持加法、减法的计算机上进行计算。

#### 4. 对于某个需要完成的功能，如果既可以通过硬件上增加电路来实现，也可以通过其他已有指令的组合来实现，那么如何判断哪一种比较合适？

对于某个需要完成的功能，如果既可以通过硬件上增加电路来实现，也可以通过其他已有指令的组合来实现，应该综合考虑多个因素来决定哪一种方式比较合适，其中包括：

1. 效率：硬件实现通常比软件实现更高效，因为硬件可以并行执行多个操作。但是，硬件实现需要消耗更多的资源，如面积、功耗、成本等，需要权衡效率和资源消耗之间的平衡。
2. 灵活性：软件实现通常比硬件实现更灵活，因为软件可以根据需要动态调整，而硬件则需要在设计时确定。但是，灵活性往往需要付出一定的效率代价。
3. 指令集架构：RISC和CISC是两种指令集架构，RISC指令集简单、执行速度快，CISC指令集复杂、执行速度慢但功能丰富。在不同的架构下，不同的操作可能会有不同的执行效率和资源消耗。
4. 应用场景：不同的应用场景需要不同的功能和性能要求。一些应用场景可能更适合硬件实现，而另一些则更适合通过软件实现。

因此，应该根据具体的应用场景和需求，综合考虑以上因素来决定哪一种方式更合适。
